import "./chunk-E2JEHENU.js";

// node_modules/@oslojs/encoding/dist/hex.js
function encodeHexUpperCase(data) {
  let result = "";
  for (let i = 0; i < data.length; i++) {
    result += alphabetUpperCase[data[i] >> 4];
    result += alphabetUpperCase[data[i] & 15];
  }
  return result;
}
function encodeHexLowerCase(data) {
  let result = "";
  for (let i = 0; i < data.length; i++) {
    result += alphabetLowerCase[data[i] >> 4];
    result += alphabetLowerCase[data[i] & 15];
  }
  return result;
}
function decodeHex(data) {
  if (data.length % 2 !== 0) {
    throw new Error("Invalid hex string");
  }
  const result = new Uint8Array(data.length / 2);
  for (let i = 0; i < data.length; i += 2) {
    if (!(data[i] in decodeMap)) {
      throw new Error("Invalid character");
    }
    if (!(data[i + 1] in decodeMap)) {
      throw new Error("Invalid character");
    }
    result[i / 2] |= decodeMap[data[i]] << 4;
    result[i / 2] |= decodeMap[data[i + 1]];
  }
  return result;
}
var alphabetUpperCase = "0123456789ABCDEF";
var alphabetLowerCase = "0123456789abcdef";
var decodeMap = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};

// node_modules/@oslojs/encoding/dist/base32.js
function encodeBase32UpperCase(bytes) {
  return encodeBase32_internal(bytes, base32UpperCaseAlphabet, EncodingPadding.Include);
}
function encodeBase32UpperCaseNoPadding(bytes) {
  return encodeBase32_internal(bytes, base32UpperCaseAlphabet, EncodingPadding.None);
}
function encodeBase32LowerCase(bytes) {
  return encodeBase32_internal(bytes, base32LowerCaseAlphabet, EncodingPadding.Include);
}
function encodeBase32LowerCaseNoPadding(bytes) {
  return encodeBase32_internal(bytes, base32LowerCaseAlphabet, EncodingPadding.None);
}
function encodeBase32(bytes) {
  return encodeBase32UpperCase(bytes);
}
function encodeBase32NoPadding(bytes) {
  return encodeBase32UpperCaseNoPadding(bytes);
}
function encodeBase32_internal(bytes, alphabet, padding) {
  let result = "";
  for (let i = 0; i < bytes.byteLength; i += 5) {
    let buffer = 0n;
    let bufferBitSize = 0;
    for (let j = 0; j < 5 && i + j < bytes.byteLength; j++) {
      buffer = buffer << 8n | BigInt(bytes[i + j]);
      bufferBitSize += 8;
    }
    if (bufferBitSize % 5 !== 0) {
      buffer = buffer << BigInt(5 - bufferBitSize % 5);
      bufferBitSize += 5 - bufferBitSize % 5;
    }
    for (let j = 0; j < 8; j++) {
      if (bufferBitSize >= 5) {
        result += alphabet[Number(buffer >> BigInt(bufferBitSize - 5) & 0x1fn)];
        bufferBitSize -= 5;
      } else if (bufferBitSize > 0) {
        result += alphabet[Number(buffer << BigInt(6 - bufferBitSize) & 0x3fn)];
        bufferBitSize = 0;
      } else if (padding === EncodingPadding.Include) {
        result += "=";
      }
    }
  }
  return result;
}
function decodeBase32(encoded) {
  return decodeBase32_internal(encoded, base32DecodeMap, DecodingPadding.Required);
}
function decodeBase32IgnorePadding(encoded) {
  return decodeBase32_internal(encoded, base32DecodeMap, DecodingPadding.Ignore);
}
function decodeBase32_internal(encoded, decodeMap2, padding) {
  const result = new Uint8Array(Math.ceil(encoded.length / 8) * 5);
  let totalBytes = 0;
  for (let i = 0; i < encoded.length; i += 8) {
    let chunk = 0n;
    let bitsRead = 0;
    for (let j = 0; j < 8; j++) {
      if (padding === DecodingPadding.Required) {
        if (encoded[i + j] === "=") {
          continue;
        }
        if (i + j >= encoded.length) {
          throw new Error("Invalid padding");
        }
      }
      if (padding === DecodingPadding.Ignore) {
        if (i + j >= encoded.length || encoded[i + j] === "=") {
          continue;
        }
      }
      if (j > 0 && encoded[i + j - 1] === "=") {
        throw new Error("Invalid padding");
      }
      if (!(encoded[i + j] in decodeMap2)) {
        throw new Error("Invalid character");
      }
      chunk |= BigInt(decodeMap2[encoded[i + j]]) << BigInt((7 - j) * 5);
      bitsRead += 5;
    }
    if (bitsRead < 40) {
      let unused;
      if (bitsRead === 10) {
        unused = chunk & 0xffffffffn;
      } else if (bitsRead === 20) {
        unused = chunk & 0xffffffn;
      } else if (bitsRead === 25) {
        unused = chunk & 0xffffn;
      } else if (bitsRead === 35) {
        unused = chunk & 0xffn;
      } else {
        throw new Error("Invalid padding");
      }
      if (unused !== 0n) {
        throw new Error("Invalid padding");
      }
    }
    const byteLength = Math.floor(bitsRead / 8);
    for (let i2 = 0; i2 < byteLength; i2++) {
      result[totalBytes] = Number(chunk >> BigInt(32 - i2 * 8) & 0xffn);
      totalBytes++;
    }
  }
  return result.slice(0, totalBytes);
}
var base32UpperCaseAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
var base32LowerCaseAlphabet = "abcdefghijklmnopqrstuvwxyz234567";
var base32DecodeMap = {
  A: 0,
  B: 1,
  C: 2,
  D: 3,
  E: 4,
  F: 5,
  G: 6,
  H: 7,
  I: 8,
  J: 9,
  K: 10,
  L: 11,
  M: 12,
  N: 13,
  O: 14,
  P: 15,
  Q: 16,
  R: 17,
  S: 18,
  T: 19,
  U: 20,
  V: 21,
  W: 22,
  X: 23,
  Y: 24,
  Z: 25,
  a: 0,
  b: 1,
  c: 2,
  d: 3,
  e: 4,
  f: 5,
  g: 6,
  h: 7,
  i: 8,
  j: 9,
  k: 10,
  l: 11,
  m: 12,
  n: 13,
  o: 14,
  p: 15,
  q: 16,
  r: 17,
  s: 18,
  t: 19,
  u: 20,
  v: 21,
  w: 22,
  x: 23,
  y: 24,
  z: 25,
  "2": 26,
  "3": 27,
  "4": 28,
  "5": 29,
  "6": 30,
  "7": 31
};
var EncodingPadding;
(function(EncodingPadding3) {
  EncodingPadding3[EncodingPadding3["Include"] = 0] = "Include";
  EncodingPadding3[EncodingPadding3["None"] = 1] = "None";
})(EncodingPadding || (EncodingPadding = {}));
var DecodingPadding;
(function(DecodingPadding3) {
  DecodingPadding3[DecodingPadding3["Required"] = 0] = "Required";
  DecodingPadding3[DecodingPadding3["Ignore"] = 1] = "Ignore";
})(DecodingPadding || (DecodingPadding = {}));

// node_modules/@oslojs/encoding/dist/base64.js
function encodeBase64(bytes) {
  return encodeBase64_internal(bytes, base64Alphabet, EncodingPadding2.Include);
}
function encodeBase64NoPadding(bytes) {
  return encodeBase64_internal(bytes, base64Alphabet, EncodingPadding2.None);
}
function encodeBase64url(bytes) {
  return encodeBase64_internal(bytes, base64urlAlphabet, EncodingPadding2.Include);
}
function encodeBase64urlNoPadding(bytes) {
  return encodeBase64_internal(bytes, base64urlAlphabet, EncodingPadding2.None);
}
function encodeBase64_internal(bytes, alphabet, padding) {
  let result = "";
  for (let i = 0; i < bytes.byteLength; i += 3) {
    let buffer = 0;
    let bufferBitSize = 0;
    for (let j = 0; j < 3 && i + j < bytes.byteLength; j++) {
      buffer = buffer << 8 | bytes[i + j];
      bufferBitSize += 8;
    }
    for (let j = 0; j < 4; j++) {
      if (bufferBitSize >= 6) {
        result += alphabet[buffer >> bufferBitSize - 6 & 63];
        bufferBitSize -= 6;
      } else if (bufferBitSize > 0) {
        result += alphabet[buffer << 6 - bufferBitSize & 63];
        bufferBitSize = 0;
      } else if (padding === EncodingPadding2.Include) {
        result += "=";
      }
    }
  }
  return result;
}
var base64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var base64urlAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
function decodeBase64(encoded) {
  return decodeBase64_internal(encoded, base64DecodeMap, DecodingPadding2.Required);
}
function decodeBase64IgnorePadding(encoded) {
  return decodeBase64_internal(encoded, base64DecodeMap, DecodingPadding2.Ignore);
}
function decodeBase64url(encoded) {
  return decodeBase64_internal(encoded, base64urlDecodeMap, DecodingPadding2.Required);
}
function decodeBase64urlIgnorePadding(encoded) {
  return decodeBase64_internal(encoded, base64urlDecodeMap, DecodingPadding2.Ignore);
}
function decodeBase64_internal(encoded, decodeMap2, padding) {
  const result = new Uint8Array(Math.ceil(encoded.length / 4) * 3);
  let totalBytes = 0;
  for (let i = 0; i < encoded.length; i += 4) {
    let chunk = 0;
    let bitsRead = 0;
    for (let j = 0; j < 4; j++) {
      if (padding === DecodingPadding2.Required && encoded[i + j] === "=") {
        continue;
      }
      if (padding === DecodingPadding2.Ignore && (i + j >= encoded.length || encoded[i + j] === "=")) {
        continue;
      }
      if (j > 0 && encoded[i + j - 1] === "=") {
        throw new Error("Invalid padding");
      }
      if (!(encoded[i + j] in decodeMap2)) {
        throw new Error("Invalid character");
      }
      chunk |= decodeMap2[encoded[i + j]] << (3 - j) * 6;
      bitsRead += 6;
    }
    if (bitsRead < 24) {
      let unused;
      if (bitsRead === 12) {
        unused = chunk & 65535;
      } else if (bitsRead === 18) {
        unused = chunk & 255;
      } else {
        throw new Error("Invalid padding");
      }
      if (unused !== 0) {
        throw new Error("Invalid padding");
      }
    }
    const byteLength = Math.floor(bitsRead / 8);
    for (let i2 = 0; i2 < byteLength; i2++) {
      result[totalBytes] = chunk >> 16 - i2 * 8 & 255;
      totalBytes++;
    }
  }
  return result.slice(0, totalBytes);
}
var EncodingPadding2;
(function(EncodingPadding3) {
  EncodingPadding3[EncodingPadding3["Include"] = 0] = "Include";
  EncodingPadding3[EncodingPadding3["None"] = 1] = "None";
})(EncodingPadding2 || (EncodingPadding2 = {}));
var DecodingPadding2;
(function(DecodingPadding3) {
  DecodingPadding3[DecodingPadding3["Required"] = 0] = "Required";
  DecodingPadding3[DecodingPadding3["Ignore"] = 1] = "Ignore";
})(DecodingPadding2 || (DecodingPadding2 = {}));
var base64DecodeMap = {
  "0": 52,
  "1": 53,
  "2": 54,
  "3": 55,
  "4": 56,
  "5": 57,
  "6": 58,
  "7": 59,
  "8": 60,
  "9": 61,
  A: 0,
  B: 1,
  C: 2,
  D: 3,
  E: 4,
  F: 5,
  G: 6,
  H: 7,
  I: 8,
  J: 9,
  K: 10,
  L: 11,
  M: 12,
  N: 13,
  O: 14,
  P: 15,
  Q: 16,
  R: 17,
  S: 18,
  T: 19,
  U: 20,
  V: 21,
  W: 22,
  X: 23,
  Y: 24,
  Z: 25,
  a: 26,
  b: 27,
  c: 28,
  d: 29,
  e: 30,
  f: 31,
  g: 32,
  h: 33,
  i: 34,
  j: 35,
  k: 36,
  l: 37,
  m: 38,
  n: 39,
  o: 40,
  p: 41,
  q: 42,
  r: 43,
  s: 44,
  t: 45,
  u: 46,
  v: 47,
  w: 48,
  x: 49,
  y: 50,
  z: 51,
  "+": 62,
  "/": 63
};
var base64urlDecodeMap = {
  "0": 52,
  "1": 53,
  "2": 54,
  "3": 55,
  "4": 56,
  "5": 57,
  "6": 58,
  "7": 59,
  "8": 60,
  "9": 61,
  A: 0,
  B: 1,
  C: 2,
  D: 3,
  E: 4,
  F: 5,
  G: 6,
  H: 7,
  I: 8,
  J: 9,
  K: 10,
  L: 11,
  M: 12,
  N: 13,
  O: 14,
  P: 15,
  Q: 16,
  R: 17,
  S: 18,
  T: 19,
  U: 20,
  V: 21,
  W: 22,
  X: 23,
  Y: 24,
  Z: 25,
  a: 26,
  b: 27,
  c: 28,
  d: 29,
  e: 30,
  f: 31,
  g: 32,
  h: 33,
  i: 34,
  j: 35,
  k: 36,
  l: 37,
  m: 38,
  n: 39,
  o: 40,
  p: 41,
  q: 42,
  r: 43,
  s: 44,
  t: 45,
  u: 46,
  v: 47,
  w: 48,
  x: 49,
  y: 50,
  z: 51,
  "-": 62,
  _: 63
};
export {
  decodeBase32,
  decodeBase32IgnorePadding,
  decodeBase64,
  decodeBase64IgnorePadding,
  decodeBase64url,
  decodeBase64urlIgnorePadding,
  decodeHex,
  encodeBase32,
  encodeBase32LowerCase,
  encodeBase32LowerCaseNoPadding,
  encodeBase32NoPadding,
  encodeBase32UpperCase,
  encodeBase32UpperCaseNoPadding,
  encodeBase64,
  encodeBase64NoPadding,
  encodeBase64url,
  encodeBase64urlNoPadding,
  encodeHexLowerCase,
  encodeHexUpperCase
};
//# sourceMappingURL=@oslojs_encoding.js.map
